<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>compare two binary diagnostic tests | Ju' Research and Life</title><meta name=keywords content="diagnostic,statistic,Rpackage"><meta name=description content="如何比較兩個診斷方式的準確性？ 幾個可以比較的指標 sensitivity (Se) = 病人有病且可以被診斷出有病的機率
specificity (Sp) = 病人沒病且可以被診斷沒病的機率
positive predicted value (PPV) = 被診斷為有病而實際上真的有病的機率
negative predicted value (NPV) = 被診斷為沒病而實際上真的沒病的機率
可以使用的方法 統計方法 比較的指標 McNemar test sensitivity、specificity GEE PPV、NPV weighted generalized score PPV、NPV 如何計算 GEE 的計算很難，而且在使用上的結果比較不直觀。雖然說Leisenring等人（2000）的概念令我感到驚豔（原來還可以這樣子用哦！）。他們以疾病的狀態為依變項做logistic GEE。二分的診斷結果X、二分的診斷工具Z為兩個預測變項。就變成了 $$logit(D) = \beta_1 Z + \beta_2 X + \beta_3 ZX$$ X = 1時，Z的係數是否顯著代表了兩個診斷工具的PPV是否有顯著差異；而X = 0時Z的係數則是NPV的差異。 所以要比較NPV時就看$\beta_1$有沒有顯著，但是在比較PPV時則是要看$\beta_1 + \beta_3$，這個檢定就比較難做。
weighted generalized score是近期比較多人使用的。而這個指標在計算上也是在不同的文獻當中有許多的改進。幸好最近有人將這些方法寫成了R的套件，有和DTComPair和compbdt兩個。
不過最近（2022/10/18）我發現DTComPair在新版的R已經不支援了，可能要找舊版的R去安裝，或是希望作者可以有更新。目前可能暫時就剩下compbdt可以使用。
compbdt的使用 compbdt其實不是一個完整的套件，只有一個函式，可以在原始論文的補充資料當中獲得。
使用時需要輸入兩種診斷工具的診斷結果（見下表）
compbdt(s11 = s11, s10 = s10, s01 = s01, s00 = s00, r11 = r11, r10 = r10, r01 = r01, r00 = r00, alpha = ."><meta name=author content="Ju"><link rel=canonical href=https://juyujeng.github.io/researchlife/docs/methods/compare-two-binary-diagnostic-tests/><link crossorigin=anonymous href=/researchlife/assets/css/stylesheet.cb6161d21234b928031cf6aa795fd2bdad5c2483cefd0557b9eb0ed142628e25.css integrity="sha256-y2Fh0hI0uSgDHPaqeV/Sva1cJIPO/QVXuesO0UJijiU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/researchlife/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://juyujeng.github.io/researchlife/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://juyujeng.github.io/researchlife/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://juyujeng.github.io/researchlife/favicon-32x32.png><link rel=apple-touch-icon href=https://juyujeng.github.io/researchlife/apple-touch-icon.png><link rel=mask-icon href=https://juyujeng.github.io/researchlife/safari-pinned-tab.svg><link rel=manifest href=/site.webmanifest><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-8XNMY2VF63"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8XNMY2VF63",{anonymize_ip:!1})}</script><meta property="og:title" content="compare two binary diagnostic tests"><meta property="og:description" content="如何比較兩個診斷方式的準確性？ 幾個可以比較的指標 sensitivity (Se) = 病人有病且可以被診斷出有病的機率
specificity (Sp) = 病人沒病且可以被診斷沒病的機率
positive predicted value (PPV) = 被診斷為有病而實際上真的有病的機率
negative predicted value (NPV) = 被診斷為沒病而實際上真的沒病的機率
可以使用的方法 統計方法 比較的指標 McNemar test sensitivity、specificity GEE PPV、NPV weighted generalized score PPV、NPV 如何計算 GEE 的計算很難，而且在使用上的結果比較不直觀。雖然說Leisenring等人（2000）的概念令我感到驚豔（原來還可以這樣子用哦！）。他們以疾病的狀態為依變項做logistic GEE。二分的診斷結果X、二分的診斷工具Z為兩個預測變項。就變成了 $$logit(D) = \beta_1 Z + \beta_2 X + \beta_3 ZX$$ X = 1時，Z的係數是否顯著代表了兩個診斷工具的PPV是否有顯著差異；而X = 0時Z的係數則是NPV的差異。 所以要比較NPV時就看$\beta_1$有沒有顯著，但是在比較PPV時則是要看$\beta_1 + \beta_3$，這個檢定就比較難做。
weighted generalized score是近期比較多人使用的。而這個指標在計算上也是在不同的文獻當中有許多的改進。幸好最近有人將這些方法寫成了R的套件，有和DTComPair和compbdt兩個。
不過最近（2022/10/18）我發現DTComPair在新版的R已經不支援了，可能要找舊版的R去安裝，或是希望作者可以有更新。目前可能暫時就剩下compbdt可以使用。
compbdt的使用 compbdt其實不是一個完整的套件，只有一個函式，可以在原始論文的補充資料當中獲得。
使用時需要輸入兩種診斷工具的診斷結果（見下表）
compbdt(s11 = s11, s10 = s10, s01 = s01, s00 = s00, r11 = r11, r10 = r10, r01 = r01, r00 = r00, alpha = ."><meta property="og:type" content="article"><meta property="og:url" content="https://juyujeng.github.io/researchlife/docs/methods/compare-two-binary-diagnostic-tests/"><meta property="og:image" content="https://juyujeng.github.io/researchlife/docs/methods/images/compbdt.svg"><meta property="article:section" content="docs"><meta property="article:published_time" content="2022-10-18T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-31T21:41:39+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://juyujeng.github.io/researchlife/docs/methods/images/compbdt.svg"><meta name=twitter:title content="compare two binary diagnostic tests"><meta name=twitter:description content="如何比較兩個診斷方式的準確性？ 幾個可以比較的指標 sensitivity (Se) = 病人有病且可以被診斷出有病的機率
specificity (Sp) = 病人沒病且可以被診斷沒病的機率
positive predicted value (PPV) = 被診斷為有病而實際上真的有病的機率
negative predicted value (NPV) = 被診斷為沒病而實際上真的沒病的機率
可以使用的方法 統計方法 比較的指標 McNemar test sensitivity、specificity GEE PPV、NPV weighted generalized score PPV、NPV 如何計算 GEE 的計算很難，而且在使用上的結果比較不直觀。雖然說Leisenring等人（2000）的概念令我感到驚豔（原來還可以這樣子用哦！）。他們以疾病的狀態為依變項做logistic GEE。二分的診斷結果X、二分的診斷工具Z為兩個預測變項。就變成了 $$logit(D) = \beta_1 Z + \beta_2 X + \beta_3 ZX$$ X = 1時，Z的係數是否顯著代表了兩個診斷工具的PPV是否有顯著差異；而X = 0時Z的係數則是NPV的差異。 所以要比較NPV時就看$\beta_1$有沒有顯著，但是在比較PPV時則是要看$\beta_1 + \beta_3$，這個檢定就比較難做。
weighted generalized score是近期比較多人使用的。而這個指標在計算上也是在不同的文獻當中有許多的改進。幸好最近有人將這些方法寫成了R的套件，有和DTComPair和compbdt兩個。
不過最近（2022/10/18）我發現DTComPair在新版的R已經不支援了，可能要找舊版的R去安裝，或是希望作者可以有更新。目前可能暫時就剩下compbdt可以使用。
compbdt的使用 compbdt其實不是一個完整的套件，只有一個函式，可以在原始論文的補充資料當中獲得。
使用時需要輸入兩種診斷工具的診斷結果（見下表）
compbdt(s11 = s11, s10 = s10, s01 = s01, s00 = s00, r11 = r11, r10 = r10, r01 = r01, r00 = r00, alpha = ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Docs","item":"https://juyujeng.github.io/researchlife/docs/"},{"@type":"ListItem","position":2,"name":"🧰 methods","item":"https://juyujeng.github.io/researchlife/docs/methods/"},{"@type":"ListItem","position":3,"name":"compare two binary diagnostic tests","item":"https://juyujeng.github.io/researchlife/docs/methods/compare-two-binary-diagnostic-tests/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"compare two binary diagnostic tests","name":"compare two binary diagnostic tests","description":"如何比較兩個診斷方式的準確性？ 幾個可以比較的指標 sensitivity (Se) = 病人有病且可以被診斷出有病的機率\nspecificity (Sp) = 病人沒病且可以被診斷沒病的機率\npositive predicted value (PPV) = 被診斷為有病而實際上真的有病的機率\nnegative predicted value (NPV) = 被診斷為沒病而實際上真的沒病的機率\n可以使用的方法 統計方法 比較的指標 McNemar test sensitivity、specificity GEE PPV、NPV weighted generalized score PPV、NPV 如何計算 GEE 的計算很難，而且在使用上的結果比較不直觀。雖然說Leisenring等人（2000）的概念令我感到驚豔（原來還可以這樣子用哦！）。他們以疾病的狀態為依變項做logistic GEE。二分的診斷結果X、二分的診斷工具Z為兩個預測變項。就變成了 $$logit(D) = \\beta_1 Z + \\beta_2 X + \\beta_3 ZX$$ X = 1時，Z的係數是否顯著代表了兩個診斷工具的PPV是否有顯著差異；而X = 0時Z的係數則是NPV的差異。 所以要比較NPV時就看$\\beta_1$有沒有顯著，但是在比較PPV時則是要看$\\beta_1 + \\beta_3$，這個檢定就比較難做。\nweighted generalized score是近期比較多人使用的。而這個指標在計算上也是在不同的文獻當中有許多的改進。幸好最近有人將這些方法寫成了R的套件，有和DTComPair和compbdt兩個。\n不過最近（2022/10/18）我發現DTComPair在新版的R已經不支援了，可能要找舊版的R去安裝，或是希望作者可以有更新。目前可能暫時就剩下compbdt可以使用。\ncompbdt的使用 compbdt其實不是一個完整的套件，只有一個函式，可以在原始論文的補充資料當中獲得。\n使用時需要輸入兩種診斷工具的診斷結果（見下表）\ncompbdt(s11 = s11, s10 = s10, s01 = s01, s00 = s00, r11 = r11, r10 = r10, r01 = r01, r00 = r00, alpha = .","keywords":["diagnostic","statistic","Rpackage"],"articleBody":"如何比較兩個診斷方式的準確性？ 幾個可以比較的指標 sensitivity (Se) = 病人有病且可以被診斷出有病的機率\nspecificity (Sp) = 病人沒病且可以被診斷沒病的機率\npositive predicted value (PPV) = 被診斷為有病而實際上真的有病的機率\nnegative predicted value (NPV) = 被診斷為沒病而實際上真的沒病的機率\n可以使用的方法 統計方法 比較的指標 McNemar test sensitivity、specificity GEE PPV、NPV weighted generalized score PPV、NPV 如何計算 GEE 的計算很難，而且在使用上的結果比較不直觀。雖然說Leisenring等人（2000）的概念令我感到驚豔（原來還可以這樣子用哦！）。他們以疾病的狀態為依變項做logistic GEE。二分的診斷結果X、二分的診斷工具Z為兩個預測變項。就變成了 $$logit(D) = \\beta_1 Z + \\beta_2 X + \\beta_3 ZX$$ X = 1時，Z的係數是否顯著代表了兩個診斷工具的PPV是否有顯著差異；而X = 0時Z的係數則是NPV的差異。 所以要比較NPV時就看$\\beta_1$有沒有顯著，但是在比較PPV時則是要看$\\beta_1 + \\beta_3$，這個檢定就比較難做。\nweighted generalized score是近期比較多人使用的。而這個指標在計算上也是在不同的文獻當中有許多的改進。幸好最近有人將這些方法寫成了R的套件，有和DTComPair和compbdt兩個。\n不過最近（2022/10/18）我發現DTComPair在新版的R已經不支援了，可能要找舊版的R去安裝，或是希望作者可以有更新。目前可能暫時就剩下compbdt可以使用。\ncompbdt的使用 compbdt其實不是一個完整的套件，只有一個函式，可以在原始論文的補充資料當中獲得。\n使用時需要輸入兩種診斷工具的診斷結果（見下表）\ncompbdt(s11 = s11, s10 = s10, s01 = s01, s00 = s00, r11 = r11, r10 = r10, r01 = r01, r00 = r00, alpha = .05) 兩個診斷工具的診斷結果代號表（取自Roldán-Nofuentes, 2020） 這個函式的寫法會直接把分析的結果輸出到畫面上，並不會回傳任何資料。如果想要讓該函式回傳需要的統計值的話，需要自行修改作者提供的程式碼\n例如我要輸出兩個診斷的PPV和NPV以及這兩個指標的比較統計值，我便在最後加上這些程式碼\nreturn(list(PPV1 = PPV1, # PPV for test 1 PPV2 = PPV2, # PPV for test 2 NPV1 = NPV1, # NPV for test 1 NPV2 = NPV2, # NPV for test 2 wald.s = Q1, # wald test statistics wald.p = globalpvalue3[1,1], # wald test p value wgst.ppv = T1, # PPV weighted generalized statistic wgsp.ppv = pvalue7, # PPV statistic p value wgst.npv = T2, # NPV weighted generalized statistic wgsp.npv = pvalue8)) # NPV statistic p value references Kosinski, A. S. (2013). A weighted generalized score statistic for comparison of predictive values of diagnostic tests. Statistics in Medicine, 32(6), 964–977. https://doi.org/10.1002/sim.5587\nLeisenring, W., Alono, T., \u0026 Pepe, M. S. (2000). Comparisons of Predictive Values of Binary Medical Diagnostic Tests for Paired Designs. Biometrics, 56(2), 345–351. https://doi.org/10.1111/j.0006-341X.2000.00345.x\nRoldán Nofuentes, J. A., Luna del Castillo, J. de D., \u0026 Montero Alonso, M. Á. (2012). Global hypothesis test to simultaneously compare the predictive values of two binary diagnostic tests. Computational Statistics \u0026 Data Analysis, 56(5), 1161–1173. https://doi.org/10.1016/j.csda.2011.06.003\nRoldán-Nofuentes, J. A. (2020). Compbdt: An R program to compare two binary diagnostic tests subject to a paired design. BMC Medical Research Methodology, 20(1), 143. https://doi.org/10.1186/s12874-020-00988-y\n","wordCount":"286","inLanguage":"en","image":"https://juyujeng.github.io/researchlife/docs/methods/images/compbdt.svg","datePublished":"2022-10-18T00:00:00Z","dateModified":"2022-10-31T21:41:39+08:00","author":{"@type":"Person","name":"Ju"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://juyujeng.github.io/researchlife/docs/methods/compare-two-binary-diagnostic-tests/"},"publisher":{"@type":"Organization","name":"Ju' Research and Life","logo":{"@type":"ImageObject","url":"https://juyujeng.github.io/researchlife/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://juyujeng.github.io/researchlife/ accesskey=h title="Ju' Research & Life (Alt + H)"><img src=https://juyujeng.github.io/researchlife/apple-touch-icon.png alt aria-label=logo height=30>Ju' Research & Life</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://juyujeng.github.io/researchlife/about title="About Me"><span>About Me</span></a></li><li><a href=https://juyujeng.github.io/researchlife/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://juyujeng.github.io/researchlife/docs/ title=Document><span>Document</span></a></li><li><a href=https://juyujeng.github.io/researchlife/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://juyujeng.github.io/researchlife/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://juyujeng.github.io/researchlife/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>compare two binary diagnostic tests</h1><div class=post-meta><span title='2022-10-18 00:00:00 +0000 UTC'>October 18, 2022</span>&nbsp;·&nbsp;Ju</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%a6%82%e4%bd%95%e6%af%94%e8%bc%83%e5%85%a9%e5%80%8b%e8%a8%ba%e6%96%b7%e6%96%b9%e5%bc%8f%e7%9a%84%e6%ba%96%e7%a2%ba%e6%80%a7 aria-label=如何比較兩個診斷方式的準確性？>如何比較兩個診斷方式的準確性？</a><ul><li><a href=#%e5%b9%be%e5%80%8b%e5%8f%af%e4%bb%a5%e6%af%94%e8%bc%83%e7%9a%84%e6%8c%87%e6%a8%99 aria-label=幾個可以比較的指標>幾個可以比較的指標</a></li><li><a href=#%e5%8f%af%e4%bb%a5%e4%bd%bf%e7%94%a8%e7%9a%84%e6%96%b9%e6%b3%95 aria-label=可以使用的方法>可以使用的方法</a></li><li><a href=#%e5%a6%82%e4%bd%95%e8%a8%88%e7%ae%97 aria-label=如何計算>如何計算</a><ul><li><a href=#compbdt%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=compbdt的使用>compbdt的使用</a></li></ul></li><li><a href=#references aria-label=references>references</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=如何比較兩個診斷方式的準確性>如何比較兩個診斷方式的準確性？<a hidden class=anchor aria-hidden=true href=#如何比較兩個診斷方式的準確性>#</a></h1><h2 id=幾個可以比較的指標>幾個可以比較的指標<a hidden class=anchor aria-hidden=true href=#幾個可以比較的指標>#</a></h2><p>sensitivity (<em>Se</em>) = 病人有病且可以被診斷出有病的機率</p><p>specificity (<em>Sp</em>) = 病人沒病且可以被診斷沒病的機率</p><p>positive predicted value (<em>PPV</em>) = 被診斷為有病而實際上真的有病的機率</p><p>negative predicted value (<em>NPV</em>) = 被診斷為沒病而實際上真的沒病的機率</p><h2 id=可以使用的方法>可以使用的方法<a hidden class=anchor aria-hidden=true href=#可以使用的方法>#</a></h2><table><thead><tr><th>統計方法</th><th>比較的指標</th></tr></thead><tbody><tr><td>McNemar test</td><td>sensitivity、specificity</td></tr><tr><td>GEE</td><td>PPV、NPV</td></tr><tr><td>weighted generalized score</td><td>PPV、NPV</td></tr></tbody></table><h2 id=如何計算>如何計算<a hidden class=anchor aria-hidden=true href=#如何計算>#</a></h2><p>GEE 的計算很難，而且在使用上的結果比較不直觀。雖然說Leisenring等人（2000）的概念令我感到驚豔（原來還可以這樣子用哦！）。他們以疾病的狀態為依變項做logistic GEE。二分的診斷結果X、二分的診斷工具Z為兩個預測變項。就變成了 $$logit(D) = \beta_1 Z + \beta_2 X + \beta_3 ZX$$
X = 1時，Z的係數是否顯著代表了兩個診斷工具的PPV是否有顯著差異；而X = 0時Z的係數則是NPV的差異。 所以要比較NPV時就看$\beta_1$有沒有顯著，但是在比較PPV時則是要看$\beta_1 + \beta_3$，這個檢定就比較難做。</p><p>weighted generalized score是近期比較多人使用的。而這個指標在計算上也是在不同的文獻當中有許多的改進。幸好最近有人將這些方法寫成了R的套件，有和<code>DTComPair</code>和<code>compbdt</code>兩個。</p><p>不過最近（2022/10/18）我發現<code>DTComPair</code>在新版的R已經不支援了，可能要找舊版的R去安裝，或是希望作者可以有更新。目前可能暫時就剩下<code>compbdt</code>可以使用。</p><h3 id=compbdt的使用>compbdt的使用<a hidden class=anchor aria-hidden=true href=#compbdt的使用>#</a></h3><p><code>compbdt</code>其實不是一個完整的套件，只有一個函式，可以在原始論文的<a href=https://static-content.springer.com/esm/art%3A10.1186%2Fs12874-020-00988-y/MediaObjects/12874_2020_988_MOESM1_ESM.txt>補充資料</a>當中獲得。</p><p>使用時需要輸入兩種診斷工具的診斷結果（見下表）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=display:flex><span><span style=color:#a6e22e>compbdt</span>(s11 <span style=color:#f92672>=</span> s11, s10 <span style=color:#f92672>=</span> s10, s01 <span style=color:#f92672>=</span> s01, s00 <span style=color:#f92672>=</span> s00,
</span></span><span style=display:flex><span>        r11 <span style=color:#f92672>=</span> r11, r10 <span style=color:#f92672>=</span> r10, r01 <span style=color:#f92672>=</span> r01, r00 <span style=color:#f92672>=</span> r00,
</span></span><span style=display:flex><span>        alpha <span style=color:#f92672>=</span> <span style=color:#ae81ff>.05</span>)
</span></span></code></pre></div><p><figure><center><img src=../images/compbdt.svg alt="兩個診斷工具的診斷結果代號表（取自Roldán-Nofuentes, 2020）"><figcaption>兩個診斷工具的診斷結果代號表（取自Roldán-Nofuentes, 2020）</figcaption></center></figure></p><p>這個函式的寫法會直接把分析的結果輸出到畫面上，並不會回傳任何資料。如果想要讓該函式回傳需要的統計值的話，需要自行修改作者提供的程式碼</p><p>例如我要輸出兩個診斷的PPV和NPV以及這兩個指標的比較統計值，我便在最後加上這些程式碼</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-r data-lang=r><span style=display:flex><span><span style=color:#a6e22e>return</span>(<span style=color:#a6e22e>list</span>(PPV1 <span style=color:#f92672>=</span> PPV1, <span style=color:#75715e># PPV for test 1</span>
</span></span><span style=display:flex><span>            PPV2 <span style=color:#f92672>=</span> PPV2, <span style=color:#75715e># PPV for test 2</span>
</span></span><span style=display:flex><span>            NPV1 <span style=color:#f92672>=</span> NPV1, <span style=color:#75715e># NPV for test 1</span>
</span></span><span style=display:flex><span>            NPV2 <span style=color:#f92672>=</span> NPV2, <span style=color:#75715e># NPV for test 2</span>
</span></span><span style=display:flex><span>            wald.s <span style=color:#f92672>=</span> Q1, <span style=color:#75715e># wald test statistics</span>
</span></span><span style=display:flex><span>            wald.p <span style=color:#f92672>=</span> globalpvalue3[1,<span style=color:#ae81ff>1</span>], <span style=color:#75715e># wald test p value</span>
</span></span><span style=display:flex><span>            wgst.ppv <span style=color:#f92672>=</span> T1, <span style=color:#75715e># PPV weighted generalized statistic</span>
</span></span><span style=display:flex><span>            wgsp.ppv <span style=color:#f92672>=</span> pvalue7, <span style=color:#75715e># PPV statistic p value</span>
</span></span><span style=display:flex><span>            wgst.npv <span style=color:#f92672>=</span> T2, <span style=color:#75715e># NPV weighted generalized statistic</span>
</span></span><span style=display:flex><span>            wgsp.npv <span style=color:#f92672>=</span> pvalue8)) <span style=color:#75715e># NPV statistic p value  </span>
</span></span></code></pre></div><h2 id=references>references<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p>Kosinski, A. S. (2013). A weighted generalized score statistic for comparison of predictive values of diagnostic tests. Statistics in Medicine, 32(6), 964–977. <a href=https://doi.org/10.1002/sim.5587>https://doi.org/10.1002/sim.5587</a></p><p>Leisenring, W., Alono, T., & Pepe, M. S. (2000). Comparisons of Predictive Values of Binary Medical Diagnostic Tests for Paired Designs. Biometrics, 56(2), 345–351. <a href=https://doi.org/10.1111/j.0006-341X.2000.00345.x>https://doi.org/10.1111/j.0006-341X.2000.00345.x</a></p><p>Roldán Nofuentes, J. A., Luna del Castillo, J. de D., & Montero Alonso, M. Á. (2012). Global hypothesis test to simultaneously compare the predictive values of two binary diagnostic tests. Computational Statistics & Data Analysis, 56(5), 1161–1173. <a href=https://doi.org/10.1016/j.csda.2011.06.003>https://doi.org/10.1016/j.csda.2011.06.003</a></p><p>Roldán-Nofuentes, J. A. (2020). Compbdt: An R program to compare two binary diagnostic tests subject to a paired design. BMC Medical Research Methodology, 20(1), 143. <a href=https://doi.org/10.1186/s12874-020-00988-y>https://doi.org/10.1186/s12874-020-00988-y</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://juyujeng.github.io/researchlife/tags/diagnostic/>diagnostic</a></li><li><a href=https://juyujeng.github.io/researchlife/tags/statistic/>statistic</a></li><li><a href=https://juyujeng.github.io/researchlife/tags/rpackage/>Rpackage</a></li></ul><nav class=paginav><a class=prev href=https://juyujeng.github.io/researchlife/blog/research/potential-nonverbal-cues/><span class=title>« Prev</span><br><span>potential nonverbal cues</span></a>
<a class=next href=https://juyujeng.github.io/researchlife/docs/psychology/%E5%B0%8F%E6%99%82%E5%80%99%E7%9C%8B%E8%B6%8A%E5%A4%9A%E9%9B%BB%E8%A6%96%E8%B6%8A%E5%AE%B9%E6%98%93%E8%87%AA%E9%96%89/><span class=title>Next »</span><br><span>小時候看越多電視越容易自閉？</span></a></nav></footer></article></main><footer class=footer><span>contact me @ <a href="mailto: juyujeng@gmail.com">juyujeng@gmail.com</a></span><br><span>&copy; 2022 <a href=https://juyujeng.github.io/researchlife/>Ju' Research and Life</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>